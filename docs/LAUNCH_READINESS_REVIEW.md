# Ревью готовности к запуску (700–1000 пользователей)

**Дата:** 2026-02-08  
**Цель:** Проверка логических и бизнес-багов, готовность к первым 700–1000 пользователям.

---

## Что проверено

### 1. Платежи (Telegram Stars)

- **Idempotency:** Начисление по `telegram_payment_charge_id` — повторный successful_payment не дублирует токены. ✅
- **Атомарность:** `credit_tokens` использует `with_for_update()` по пользователю, создание Payment и изменение баланса в одной транзакции. ✅
- **Коммит:** Бот вызывает `credit_tokens` внутри `get_db_session()` → commit при выходе. ✅
- **Рефанд:** `process_refund` делает flush, админка делает `db.commit()` после вызова. ✅
- **Rate-limit покупок:** Раньше был in-memory (при нескольких репликах бота лимит обходился). **Исправлено:** лимит перенесён в Redis (`purchase_rate:{telegram_id}`), общий для всех воркеров. ✅

### 2. Токены и джобы

- **Резерв (HOLD):** `hold_tokens` — блокировка по `User` + запись в `TokenLedger`. При дубликате (IntegrityError по uq_ledger_idempotency) — rollback и return True (идемпотентность). ✅
- **Списание (CAPTURE):** Только запись в ledger при успехе генерации; баланс уже уменьшен при HOLD. ✅
- **Возврат (RELEASE):** При падении джоба — возврат баланса + запись RELEASE. ✅
- **Бесплатные/копия:** `try_use_free_generation` / `try_use_copy_generation` — атомарный UPDATE с условием по лимиту. ✅
- **Порядок в боте:** can_reserve → hold_tokens → create_job → send_task. При неудаче hold пользователь видит сообщение, джоб не создаётся. ✅

### 3. Воркер генерации

- **Повторный запуск:** Проверка `job.status in {SUCCEEDED, FAILED}` в начале — повторная обработка не дублирует результат. ✅
- **Ошибки:** При `provider_error`, `invalid_input`, `timeout` — статус FAILED, release токенов, уведомление пользователя. ✅
- **trend_missing:** Раньше пользователь не получал сообщение. **Исправлено:** добавлено уведомление «Тренд временно недоступен...» и `notify_user=True`. ✅
- **Очистка входов:** После успеха удаляются `input_local_paths` с диска и очищаются в БД. ✅

### 4. Безопасность и лимиты

- **Админ:** Валидация пароля и session_secret в config. ✅
- **Бан/подвеска:** SecurityMiddleware в боте блокирует забаненных и приостановленных. ✅
- **Rate-limit запросов:** По пользователю в Redis (`rate_limit:{tg_id}:{hour}`), с учётом VIP и подписчиков. ✅
- **Логин:** Есть login_rate_limit (попытки/окно). ✅

### 5. Инфраструктура

- **DB pool:** pool_size=10, max_overflow=20 на процесс. API, bot, worker — отдельные процессы, каждый со своим пулом. Для 700–1000 пользователей при пиках может быть 30+ одновременных запросов к БД — стоит следить за метриками и при необходимости увеличить `max_connections` в PostgreSQL или чуть уменьшить pool на сервисах.
- **Celery:** worker concurrency=2, task_acks_late=True, prefetch=1 — задачи не теряются при падении воркера. При росте нагрузки можно поднять concurrency или добавить реплики воркера. ✅
- **Redis:** Используется для FSM бота, rate-limit, idempotency, очереди Celery. Критичен для работы; при падении Redis бот и воркеры будут сбоить — нужен мониторинг. ✅

### 6. Мелкие замечания (не блокеры)

- **`debit_tokens_for_unlock`** в UserService нигде не вызывается (разблокировка только за Stars). Можно оставить под будущее «разблокировать за токены» или удалить как мёртвый код.
- **Ошибка "user_missing"** в воркере: пользователь не уведомляется (notify_user=False), т.к. пользователя нет в БД — это редкий кейс, оставлено как есть.

---

## Внесённые исправления

1. **PaymentService:** лимит покупок перенесён с in-memory на Redis; при ошибке Redis — fail open (покупка разрешается), чтобы не блокировать продажи.
2. **generation_v2:** при ошибке `trend_missing` пользователю отправляется сообщение «Тренд временно недоступен...».

---

## Итог

- Критических логических или бизнес-багов, блокирующих запуск, не найдено.
- Двойное начисление/списание токенов и двойная обработка платежей защищены (идемпотентность, блокировки, ledger).
- Для масштаба 700–1000 пользователей текущая схема (один API, один бот, один воркер с concurrency=2) в целом достаточна; при росте нагрузки имеет смысл мониторить очередь Celery, задержки ответа API и использование соединений к БД/Redis и при необходимости увеличить concurrency воркера или добавить реплики.

Рекомендуется перед запуском:

- Убедиться, что в `.env` заданы все обязательные переменные (в т.ч. `admin_ui_password`, `admin_ui_session_secret`, ключи провайдеров).
- Проверить health API и воркера после деплоя.
- Настроить алерты на падение сервисов и ошибки в логах (payment, generation, Redis).
